递归通常比迭代更加耗费内存空间  
递归通常比循环的时间效率更低  
普通递归：递归函数在return前实现  
尾递归：递归函数在return实现  
时间复杂度记为O()

如何推算时间复杂度O：
1.统计操作数量
    1.忽略操作数量T(n)中的常数项
    2.省略所有系数
    3.嵌套循环时使用乘法
2.判断渐近上界
![alt text](1.png)  
常数阶<对数阶<线性阶<线性对数阶<平方阶<指数阶<阶乘阶
![alt text](2.png)
常数阶：常数 
线性阶：单重循环n 
平方阶：嵌套之双重循环n方

通常统计暂存数据、栈帧空间和输出数据三部分作为空间复杂度
![alt text](3.png)
输出空间：用于存储算法的输出数据。
暂存数据：用于保存算法运行过程中的各种常量、变量、对象等。
栈帧空间：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。
其他的输入空间忽略，暂存空间中的指令空间忽略，而其中的暂存数据和栈帧数据计算入里面
常数阶常见于数量与输入数据大小无关的常量、变量、对象。
线性阶常见于元素数量与成正比的数组、链表、栈、队列等。
平方阶常见于矩阵和图，元素数量与n成平方关系。
指数阶常见于二叉树。
对数阶常见于分治算法。

逻辑结构揭示了数据元素之间的逻辑关系。可分为线性和非线性两大类。
线性数据结构：数组、链表、栈、队列、哈希表，元素之间是一对一的顺序关系。
非线性数据结构：树、堆、图、哈希表。
哈希表的实现可能同时包含线性数据结构和非线性数据结构。
非线性数据结构可以细分为树形结构和网状结构。
树形结构：树、堆、哈希表，元素之间是一对多的关系。
网状结构：图，元素之间是多对多的关系。

物理结构反映了数据在计算机内存中的存储方式。
物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出互补的特点。
可分为连续空间存储（数组）和分散空间存储（链表）。
所有数据结构都是基于数组、链表或二者的组合实现的。
基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量（维度≥3的数组）等。---静态数据结构
基于链表可实现：栈、队列、哈希表、树、堆、图等。---动态数据结构
基于数组实现的数据结构也称“静态数据结构”，这意味着此类数据结构在初始化后长度不可变。
相对应地，基于链表实现的数据结构也称“动态数据结构”，这类数据结构在初始化后，仍可以在程序运行过程中对其长度进行调整。

基本数据类型是 CPU 可以直接进行运算的类型
整数类型 byte、short、int、long 。
浮点数类型 float、double ，用于表示小数。
字符类型 char ，用于表示各种语言的字母、标点符号甚至表情符号等。
布尔类型 bool ，用于表示“是”与“否”判断。
基本数据类型以二进制的形式存储在计算机中。一个二进制位即为1比特。在绝大多数现代操作系统中，1字节（byte）由 8比特（bit）组成。
基本数据类型提供了数据的“内容类型”，而数据结构提供了数据的“组织方式”

二进制计算中反码变为补码的计算是 1+1=0，然后进位直至无进位（符号位或者第9位，但byte类型的长度只有8位，第9位的1会被舍弃）或者变为0+1=1为止，
例如1111 1111 + 1 = 0000 0000 --- 1110 0011 + 1 = 1110 0100 
原码：我们将数字的二进制表示的最高位视为符号位，其中0 表示正数，1表示负数，其余位表示数字的值。
反码：正数的反码与其原码相同，负数的反码是对其原码除符号位外的所有位取反。
补码：正数的补码与其原码相同，负数的补码是在其反码的基础上加1。
原码反码补码关系图
![alt text](4.png)  
其中原码虽然直观但是负数原码不能用于计算。如何解决，引入了反码 1's complement---原码转换为反码，在反码下计算再转化为原码。
数字零的原码有+0和-0两种表示方式，反码也存在正负零歧义，引入了反码 2's complement---负0的补码等同于正码的补码，则补码中只存在一个0。
为什么byte类型取值是【-128到127】呢，因为-127到127都有相应的原码反码补码，
但补码1000 0000转化为反码-->0111 1111转化为原码-->00000000=0，但0的补码应是自身，所以定义1000 0000为-128。
float和int长度相同但是取值范围更大是因为浮点数 float 采用了不同的表示方式，但其副作用是牺牲了精度。

索引本质上是内存地址的偏移量
数组的插入与删除操作有以下缺点:
时间复杂度高、丢失元素、内存浪费

数组
空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销。
支持随机访问：数组允许在O(1)时间内访问任何元素。
缓存局部性：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。
连续空间存储是一把双刃剑，其存在以下局限性。
插入与删除效率低：当数组中元素较多时，插入与删除操作需要移动大量的元素。
长度不可变：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。
空间浪费：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。
应用：随机访问、排序和搜索、查找表、机器学习、数据结构实现。

链表的组成单位是「节点 node」对象。每个节点都包含两项数据：节点的值和指向下一节点的指针
![alt text](5.PNG)  
单向链表：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None 。
环形链表：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。
双向链表：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。
链表使用分散空间存储、节点访问效率低、占用内存多、长度可变。 
应用：单链表---栈与队列、哈希表、图；双链表---高级数据结构、浏览器历史、LRU算法；环链表---时间片轮转调度算法、数据缓冲区。

列表表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无须使用者考虑容量限制的问题。

计算机中包括三种类型的存储设备：「硬盘 hard disk」、「内存 random-access memory, RAM」、「缓存 cache memory」
![alt text](6.png)  
硬盘用于长期存储大量数据，内存用于临时存储程序运行中正在处理的数据，而缓存则用于存储经常访问的数据和指令
在程序运行时，数据会从硬盘中被读取到内存中，供 CPU 计算使用。缓存可以看作 CPU 的一部分，它通过智能地从内存加载数据，给 CPU 提供高速的数据读取，从而显著提升程序的执行效率，减少对较慢的内存的依赖。

栈队列都可以基于链表和数组实现
栈stack---先进后出---出入反方向 队列queue---先进先出---出入同方向==排队状态
![alt text](7.png)  
![alt text](8.png)  
时间效率
当入栈与出栈操作的元素是基本数据类型时，例如 int 或 double
基于数组实现的栈在触发扩容时效率会降低，但由于扩容是低频操作，因此平均效率更高。
基于链表实现的栈可以提供更加稳定的效率表现。
空间效率
基于数组实现的栈可能造成一定的空间浪费。
由于链表节点需要额外存储指针，因此链表节点占用的空间相对较大。
栈的应用————浏览器中的后退与前进、软件中的撤销与反撤销、程序内存管理。
队列应用——淘宝订单、各类待办事项。 
在单向队列中，我们仅能删除头部元素或在尾部添加元素。
在双向队列deque中，允许在头部和尾部执行元素的添加或删除操作。
双向队列兼具栈与队列的逻辑，因此它可以实现这两者的所有应用场景，同时提供更高的自由度。

「哈希表 hash table」，又称「散列表」，它通过建立键 key 与值 value 之间的映射，实现高效的元素查询。
![alt text](9.png)  
由此可见哈希表非常高效。